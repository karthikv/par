module FileTest

import Test (group, capture)

uid : Int
uid =
  String.to_chars("id -u")
  |> @os:cmd/1
  |> String.from_chars
  |> String.strip
  |> to_int

stat_test : Test
stat_test = group([
  // @example
  test
    let meta = File.stat("test/lib/file/foo.txt")
    // ^ Assuming a file located at test/lib/file/foo.txt exists with the
    // contents "hello" and 0644 permissions, the following should pass:

    assert meta.size == 6
    assert meta.type == File.File
    assert meta.mode == File.Mode {
      owner = File.AllowReadWrite
      group = File.AllowRead
      other = File.AllowRead
    }

  test
    let meta = File.stat("test/lib/file/bar")
    assert meta.type == File.Directory
    assert meta.mode == File.Mode {
      owner = File.AllowAll
      group = File.AllowReadExec
      other = File.AllowReadExec
    }

  // Symlinks are resolved.
  test
    let meta = File.stat("test/lib/file/bar/baz")
    assert meta.type == File.File
    assert meta.mode == File.Mode {
      owner = File.AllowReadWrite
      group = File.AllowRead
      other = File.AllowRead
    }

  test assert capture(|-| File.stat("asdf")) == File.DoesntExist
])

lstat_test : Test
lstat_test = group([
  test
    let meta = File.lstat("test/lib/file/foo.txt")
    assert meta.size == 6
    assert meta.type == File.File
    assert meta.mode == File.Mode {
      owner = File.AllowReadWrite
      group = File.AllowRead
      other = File.AllowRead
    }

  test
    let meta = File.lstat("test/lib/file/bar")
    assert meta.type == File.Directory
    assert meta.mode == File.Mode {
      owner = File.AllowAll
      group = File.AllowReadExec
      other = File.AllowReadExec
    }

  // Symlinks aren't resolved.
  // @example
  test
    let meta = File.lstat("test/lib/file/bar/baz")
    // ^ Assuming a symlink exists at test/lib/file/bar/baz with 0755
    // permissions, the following should pass:

    assert meta.type == File.Symlink
    assert meta.mode == File.Mode {
      owner = File.AllowAll
      group = File.AllowReadExec
      other = File.AllowReadExec
    }

  test assert capture(|-| File.lstat("asdf")) == File.DoesntExist
])

exists_test : Test
exists_test = group([
  // @example
  test assert File.exists?(File.write_temp(""))
  // @example
  test assert File.exists?(File.make_temp_dir())
  // @example
  test assert !File.exists?(Path.join(File.make_temp_dir(), "new"))
  // @example
  test assert !File.exists?("asdf")
])

chmod_test : Test
chmod_test = group([
  // @example
  test
    let path = File.write_temp("")
    let new_mode = File.Mode {
      owner = File.AllowWrite
      group = File.AllowNone
      other = File.AllowExec
    }
    File.chmod(path, new_mode)
    assert File.stat(path).mode == new_mode

  test
    let new_mode = File.Mode {
      owner = File.AllowAll
      group = File.AllowAll
      other = File.AllowAll
    }
    assert capture(|-| File.chmod("asdf", new_mode)) == File.DoesntExist
])

// Can't actually test this without running as root. For now, ensure we get
// a permission error.
chown_test : Test
chown_test = test
  let path = File.write_temp("")
  assert capture(|-| File.chown(path, 0)) == File.NotPermitted

chgrp_test : Test
chgrp_test = group([
  test
    let path = File.write_temp("")
    let new_gid = if File.stat(path).gid == 0 then uid else 0
    File.chgrp(path, new_gid)
    assert File.stat(path).gid == new_gid

  test
    let path = File.write_temp("")
    assert capture(|-| File.chgrp(path, -1)) == File.NotPermitted
])

cp_test : Test
cp_test = group([
  // @example
  test
    let path = File.write_temp("foo")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.cp(path, new_path)
    assert File.read_path(new_path) == "foo"
    assert File.read_path(path) == "foo"

  test
    let path = Path.join(File.make_temp_dir(), "orig")
    let new_path = Path.join(File.make_temp_dir(), "new")
    assert capture(|-| File.cp(path, new_path)) == File.DoesntExist

  test
    let path = File.make_temp_dir()
    let new_path = Path.join(File.make_temp_dir(), "new")
    assert capture(|-| File.cp(path, new_path)) == File.IllegalDirOperation

  test
    let path = File.write_temp("foo")
    let new_path = File.write_temp("bar")

    File.cp(path, new_path)
    assert File.read_path(new_path) == "foo"
    assert File.read_path(path) == "foo"
])

mv_test : Test
mv_test = group([
  // @example
  test
    let path = File.write_temp("foo")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.mv(path, new_path)
    assert File.read_path(new_path) == "foo"
    assert !File.exists?(path)

  test
    let path = Path.join(File.make_temp_dir(), "orig")
    let new_path = Path.join(File.make_temp_dir(), "new")
    assert !File.exists?(path)

  test
    let path = File.write_temp("foo")
    let new_path = File.write_temp("bar")

    File.mv(path, new_path)
    assert File.read_path(new_path) == "foo"
    assert !File.exists?(path)
])

rm_test : Test
rm_test = group([
  // @example
  test
    let path = File.write_temp("")
    File.rm(path)
    assert !File.exists?(path)
  test assert capture(|-| File.rm("asdf")) == File.DoesntExist
  test assert capture(|-| File.rm(File.make_temp_dir())) == File.NotPermitted
])

rmdir_test : Test
rmdir_test = group([
  // @example
  test
    let path = File.make_temp_dir()
    File.rmdir(path)
    assert !File.exists?(path)
  test assert capture(|-| File.rmdir(File.write_temp(""))) == File.NotDirectory
  test
    let path = File.make_temp_dir()
    File.write_path(Path.join(path, "foo"), "bar")
    assert capture(|-| File.rmdir(path)) == File.Exists
])

ls_test : Test
ls_test = group([
  // @example
  test
    let path = File.make_temp_dir()
    File.write_path(Path.join(path, "foo"), "")
    File.write_path(Path.join(path, "bar"), "")
    File.mkdir(Path.join(path, "baz"))
    assert to_set(File.ls(path)) == #["foo", "bar", "baz"]
  test assert File.ls(File.make_temp_dir()) == []
  test assert capture(|-| File.ls(File.write_temp(""))) == File.NotDirectory
])

glob_test : Test
glob_test = group([
  // @example
  test
    let path = File.make_temp_dir()
    let foo_path = Path.join(path, "foo")
    let bar_path = Path.join(path, "bar")
    let baz_path = Path.join(path, "baz-foo")

    File.write_path(foo_path, "")
    File.write_path(bar_path, "")
    File.mkdir(baz_path)

    assert to_set(File.glob(Path.join(path, "*"))) ==
      #[foo_path, bar_path, baz_path]
    assert to_set(File.glob(Path.join(path, "*foo"))) ==
      #[foo_path, baz_path]
    assert to_set(File.glob(Path.join(path, "{foo,bar}"))) ==
      #[foo_path, bar_path]
  test assert File.glob(Path.join(File.make_temp_dir(), "new")) == []
])

mkdir_test : Test
mkdir_test = group([
  // @example
  test
    let path = Path.join(File.make_temp_dir(), "new")
    File.mkdir(path)
    assert File.stat(path).type == File.Directory
  test
    let path = Path.join_all([File.make_temp_dir(), "new", "sub"])
    assert capture(|-| File.mkdir(path)) == File.DoesntExist
  test assert capture(|-| File.mkdir(File.make_temp_dir())) == File.Exists
  test assert capture(|-| File.mkdir(File.write_temp(""))) == File.Exists
])

mkdir_p_test : Test
mkdir_p_test = group([
  test
    let path = Path.join(File.make_temp_dir(), "new")
    File.mkdir_p(path)
    assert File.stat(path).type == File.Directory
  // @example
  test
    let path = Path.join_all([File.make_temp_dir(), "new", "sub"])
    File.mkdir_p(path)
    assert File.stat(path).type == File.Directory
  test
    let path = File.make_temp_dir()
    File.mkdir_p(path)
    assert File.stat(path).type == File.Directory
  test assert capture(|-| File.mkdir_p(File.write_temp(""))) == File.Exists
])

make_temp_dir_test : Test
make_temp_dir_test = group([
  // @example
  test
    let path = File.make_temp_dir()
    assert Path.dir(path) == File.sys_temp_dir
    assert File.ls(path) == []
])

ln_test : Test
ln_test = group([
  // @example
  test
    let path = File.write_temp("foo")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.ln(path, new_path)
    assert File.read_path(new_path) == "foo"

    // Hard link should be maintained even when original is deleted.
    File.rm(path)
    assert File.read_path(new_path) == "foo"

  test
    let path = Path.join(File.make_temp_dir(), "orig")
    let new_path = Path.join(File.make_temp_dir(), "new")
    assert capture(|-| File.ln(path, new_path)) == File.DoesntExist

  test
    let path = File.write_temp("")
    let new_path = File.write_temp("")
    assert capture(|-| File.ln(path, new_path)) == File.Exists
])

ln_s_test : Test
ln_s_test = group([
  // @example
  test
    let path = File.write_temp("foo")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.ln_s(path, new_path)
    assert File.lstat(new_path).type == File.Symlink
    assert File.stat(new_path).type == File.File
    assert File.read_path(new_path) == "foo"

  test
    let path = File.write_temp("")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.ln_s(path, new_path)
    File.rm(path)
    assert !File.exists?(new_path)

  test
    let path = File.make_temp_dir()
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.ln_s(path, new_path)
    assert File.lstat(new_path).type == File.Symlink
    assert File.stat(new_path).type == File.Directory
    assert File.ls(new_path) == []

  test
    let path = Path.join(File.make_temp_dir(), "orig")
    let new_path = Path.join(File.make_temp_dir(), "new")

    File.ln_s(path, new_path)
    assert !File.exists?(new_path)

  test
    let path = File.write_temp("")
    let new_path = File.write_temp("")
    assert capture(|-| File.ln_s(path, new_path)) == File.Exists
])

readlink_test : Test
readlink_test = group([
  // @example
  test
    let path = File.write_temp("")
    let new_path = Path.join(File.make_temp_dir(), "new")
    File.ln_s(path, new_path)
    assert File.readlink(new_path) == path

  // Hardlinks cannot be resolved with readlink.
  test
    let path = File.write_temp("")
    let new_path = Path.join(File.make_temp_dir(), "new")
    File.ln(path, new_path)
    assert capture(|-| File.readlink(new_path)) == File.InvalidArgument

  test assert capture(|-| File.readlink("asdf")) == File.DoesntExist
  test assert capture(|-| File.readlink(File.write_temp(""))) ==
    File.InvalidArgument
])

read_path_test : Test
read_path_test = group([
  test assert File.read_path(File.write_temp("")) == ""
  // @example
  test assert File.read_path(File.write_temp("foo")) == "foo"
  test assert capture(|-| File.read_path("asdf")) == File.DoesntExist
])

write_path_test : Test
write_path_test = group([
  // @example
  test
    let path = Path.join(File.make_temp_dir(), "new")
    File.write_path(path, "foo")
    assert File.read_path(path) == "foo"
  test
    let path = File.write_temp("foo")
    File.write_path(path, "bar")
    assert File.read_path(path) == "bar"
  test
    let path = Path.join_all([File.make_temp_dir(), "new", "sub"])
    assert capture(|-| File.write_path(path, "foo")) == File.DoesntExist
])

write_temp_test : Test
write_temp_test = group([
  // @example
  test
    let path = File.write_temp("foo")
    assert Path.dir(path) == File.sys_temp_dir
    assert File.read_path(path) == "foo"
])

// Hard to test this in a more comprehensive way; we can't cd because that could
// affect other tests running in parallel.
cwd_test : Test
cwd_test =
  let path = Path.join(File.cwd(), "rebar.config")
  test assert File.stat(path).type == File.File

// Hard to test cd because it can affect other tests running in parallel; just
// check failure cases.
cd_test : Test
cd_test = group([
  test
    let orig_cwd = File.cwd()
    assert capture(|-| File.cd("asdf")) == File.DoesntExist
    assert File.cwd() == orig_cwd

  test
    let orig_cwd = File.cwd()
    assert capture(|-| File.cd(File.write_temp(""))) == File.NotDirectory
    assert File.cwd() == orig_cwd
])

open_test : Test
open_test = group([
  // @example
  test
    let h = File.open(File.write_temp("hey\nthere"), File.Read)
    ensure File.close(h) after
      assert File.read(h, File.All) == "hey\nthere"

  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.Append)
    assert File.read_path(path) == "hey\nthere"

    ensure File.close(h) after
      File.write(h, "where")
    assert File.read_path(path) == "hey\ntherewhere"

  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.ReadWrite)
    assert File.read_path(path) == "hey\nthere"

    ensure File.close(h) after
      assert File.read(h, File.Chars(3)) == "hey"
      File.write(h, "where")
      assert File.read(h, File.All) == "e"
    assert File.read_path(path) == "heywheree"

  test assert capture(|-| File.open(File.write_temp(""), File.Exclusive)) ==
    File.Exists

  test
    let new_path = Path.join(File.make_temp_dir(), "new")
    let h = File.open(new_path, File.Exclusive)
    ensure File.close(h) after File.write(h, "hey\nthere")
    assert File.read_path(new_path) == "hey\nthere"
])

close_test : Test
close_test = group([
  // @example
  test
    let path = File.write_temp("")
    let h = File.open(path, File.Write)

    ensure File.close(h) after
      File.write(h, "hello")
    assert File.read_path(path) == "hello"
])

read_test : Test
read_test = group([
  test
    let h = File.open(File.write_temp("hey\nthere"), File.Read)
    ensure File.close(h) after
      assert File.read(h, File.Chars(3)) == "hey"
      assert File.read(h, File.Chars(20)) == "\nthere"
      assert capture(|-| File.read(h, File.Chars(1))) == File.EndOfFile

  test
    let h = File.open(File.write_temp("hey\nthere"), File.Read)
    ensure File.close(h) after
      assert File.read(h, File.Line) == "hey\n"
      assert File.read(h, File.Line) == "there"
      assert capture(|-| File.read(h, File.Line)) == File.EndOfFile

  test
    let h = File.open(File.write_temp("hey\nthere"), File.Read)
    ensure File.close(h) after
      assert File.read(h, File.All) == "hey\nthere"
      assert capture(|-| File.read(h, File.All)) == File.EndOfFile

  // @example
  test
    let h = File.open(File.write_temp("hey\nthere"), File.Read)
    ensure File.close(h) after
      assert File.read(h, File.Line) == "hey\n"
      assert File.read(h, File.Chars(2)) == "th"
      assert File.read(h, File.All) == "ere"
])

write_test : Test
write_test = group([
  // @example
  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.Write)

    // File should be truncated.
    assert File.read_path(path) == ""

    ensure File.close(h) after
      File.write(h, "hello\n")
      File.write(h, "foo")
      File.write(h, "end")
    assert File.read_path(path) == "hello\nfooend"
])

seek_test : Test
seek_test = group([
  // @example
  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.ReadWrite)

    ensure File.close(h) after
      File.seek(h, 4)
      File.write(h, "where")
    assert File.read_path(path) == "hey\nwhere"
])

seek_end_test : Test
seek_end_test = group([
  // @example
  test
    let contents = "hey\nthere"
    let path = File.write_temp(contents)
    let h = File.open(path, File.ReadWrite)

    ensure File.close(h) after
      let end = File.seek_end(h)
      assert end == length(contents)
      assert File.tell(h) == end
      File.write(h, "where")
    assert File.read_path(path) == "hey\ntherewhere"
])

tell_test : Test
tell_test = group([
  // @example
  test
    let h = File.open(File.write_temp("hey\nthere"), File.ReadWrite)
    ensure File.close(h) after
      assert File.tell(h) == 0
      assert File.read(h, File.Line) == "hey\n"
      assert File.tell(h) == 4

      File.write(h, "foo")
      assert File.tell(h) == 7

      File.seek(h, 2)
      assert File.tell(h) == 2
      assert File.read(h, File.All) == "y\nfoore"
])

truncate_test : Test
truncate_test = group([
  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.ReadWrite)

    ensure File.close(h) after
      File.truncate(h)
    assert File.read_path(path) == ""

  // @example
  test
    let path = File.write_temp("hey\nthere")
    let h = File.open(path, File.ReadWrite)

    ensure File.close(h) after
      File.seek(h, 4)
      File.truncate(h)
    assert File.read_path(path) == "hey\n"
])
