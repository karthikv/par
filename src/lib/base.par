module Base

//-- Types
enum Option<T> {
  Some(T)
  None
}


//-- Interfaces/Implementations
interface Sized {
  length : T -> Int
  empty? : T -> Bool
}

impl Sized for String {
  length = @string:length/1
  empty?(s) = s == ""
}

impl Sized for [A] {
  length = @erlang:length/1
  empty?(l) = l == []
}

impl Sized for Set<A> {
  // subtract 1 to get rid of tag
  length(s) = @erlang:map_size(s) - 1
  empty?(s) = length(s) == 0
}

impl Sized for Map<A, B> {
  length = @erlang:map_size/1
  empty?(m) = m == {}
}

interface Mappable {
  map : (T<A>, A -> B) -> T<B>
}

impl Mappable for Option {
  map(o, f) = match o {
    Some(a) => Some(f(a))
    None => None
  }
}

impl Mappable for List {
  map(l, f) = @lists:map(f, l)
}

impl Mappable for Set {
  map(s, f) = map(to_list(s), f) |> to_set
}

impl Mappable for Map {
  map(m, f) = @maps:fold(|k, v, new_m|
    let (new_k, new_v) = f((k, v))
    @maps:put(new_k, new_v, new_m)
  , {}, m)
}

interface Collection extends Mappable {
  fold : (T<A>, F, (A, F) -> F) -> F
  filter : (T<A>, A -> Bool) -> T<A>
  find : (T<A>, A -> Bool) -> Option<A>

  filter_map : (T<A>, A -> Option<B>) -> T<B>
  map_fold : (T<A>, F, (A, F) -> (B, F)) -> (T<B>, F)

  put : (T<A>, A) -> T<A>
  delete : (T<A>, A) -> T<A>

  contains? : (T<A>, A) -> Bool
  all? : (T<A>, A -> Bool) -> Bool
  any? : (T<A>, A -> Bool) -> Bool
}

impl Collection for List {
  fold(l, init, f) = @lists:foldl(f, init, l)
  filter(l, f) = @lists:filter(f, l)
  find(l, f) = match l {
    [] => None
    [h | t] => if f(h) then Some(h) else find(t, f)
  }

  filter_map(l, f) = @lists:filtermap(|a|
    if let Some(b) = f(a) then
      assume (true, b)
    else
      false
  , l)
  map_fold(l, init, f) = @lists:mapfoldl(f, init, l)

  put(l, h) = [h | l]
  delete(l, a) = match l {
    [] => []
    [&a | t] => delete(t, a)
    [h | t] => [h | delete(t, a)]
  }

  contains?(l, a) = match l {
    [] => false
    [&a | _] => true
    [_ | t] => contains?(t, a)
  }
  all?(l, f) = @lists:all(f, l)
  any?(l, f) = @lists:any(f, l)
}

impl Collection for Set {
  fold(s, init, f) = to_list(s) |> fold(init, f)
  filter(s, f) = @maps:filter(|k, _| assume k == @"_@type" || f(k), s)
  find(s, f) = to_list(s) |> find(f)

  filter_map(s, f) = to_list(s) |> filter_map(f) |> to_set
  map_fold(s, init, f) =
    let (l, memo) = to_list(s) |> map_fold(init, f)
    (to_set(l), memo)

  put(s, a) = @maps:put(a, true, s)
  delete(s, a) = @maps:remove(a, s)

  contains?(s, a) = @maps:is_key(a, s)
  all?(s, f) = to_list(s) |> all?(f)
  any?(s, f) = to_list(s) |> any?(f)
}

impl Collection for Map {
  fold(m, init, f) = @maps:fold(|k, v, memo| f((k, v), memo), init, m)
  filter(m, f) = @maps:filter(|k, v| f((k, v)), m)
  find(m, f) = to_list(m) |> find(f)

  filter_map(m, f) = to_list(m) |> filter_map(f) |> to_map
  map_fold(m, init, f) =
    let (pairs, memo) = to_list(m) |> map_fold(init, f)
    (to_map(pairs), memo)

  put(m, (k, v)) = @maps:put(k, v, m)
  delete(m, (k, v)) = if contains?(m, (k, v)) then @maps:remove(k, m) else m

  contains?(m, (k, v)) = match @maps:find(k, m) {
    (@ok, &v) => true
    _ => false
  }
  all?(m, f) = to_list(m) |> all?(f)
  any?(m, f) = to_list(m) |> any?(f)
}


//-- Exceptions
// Can't include the key here because it could be of any type.
exception BadKey

// Used when converting a String or [Char] to an Int or Float.
exception CantParseInt(String)
exception CantParseFloat(String)


//-- Collections
first : ((A, B)) -> A
export first((a, _)) = a

second : ((A, B)) -> B
export second((_, b)) = b

head : [A] -> A
export head = @erlang:hd/1

tail : [A] -> [A]
export tail = @erlang:tl/1

lookup : (Map<K, V>, K) -> Option<V>
export lookup(m, k) = match @maps:find(k, m) {
  (@ok, v) => Some(v)
  @error => None
}

get : (Map<K, V>, K) -> V
export get(m, k) = match @maps:find(k, m) {
  (@ok, v) => v
  @error => raise BadKey
}

key? : (Map<K, V>, K) -> Bool
export key?(m, k) = @maps:is_key(k, m)

remove : (Map<K, V>, K) -> Map<K, V>
export remove(m, k) = @maps:remove(k, m)


//-- Math
abs : A ~ Num -> A ~ Num
export abs = @erlang:abs/1

ceil : Float -> Int
export ceil = @erlang:ceil/1

floor : Float -> Int
export floor = @erlang:floor/1

max : (A ~ Ord, A ~ Ord) -> A ~ Ord
export max(a, b) = if a > b then a else b

min : (A ~ Ord, A ~ Ord) -> A ~ Ord
export min(a, b) = if a < b then a else b

round : Float -> Int
export round = @erlang:round/1

trunc : Float -> Int
export trunc = @erlang:trunc/1


//-- Conversions
interface ToInt {
  to_int : T -> Int
}

impl ToInt for Float {
  to_int = trunc
}

impl ToInt for Char {
  to_int(c) = $c
}

impl ToInt for [Char] {
  to_int(chs) = match @string:to_integer(chs) {
    (i, []) => i
    _ => raise CantParseInt(@unicode:characters_to_binary(chs))
  }
}

impl ToInt for String {
  to_int(s) = match @string:to_integer(s) {
    (i, "") => i
    _ => raise CantParseInt(s)
  }
}

interface ToFloat {
  to_float : T -> Float
}

impl ToFloat for Int {
  to_float = @erlang:float/1
}

impl ToFloat for [Char] {
  to_float(chs) =
    let result = match chs {
      ['.' | _] => @string:to_float(['0' | chs])
      _ => @string:to_float(chs)
    }
    match result {
      (f, []) => f
      _ => match @string:to_integer(chs) {
        (i, []) => to_float(i : Int)
        _ => raise CantParseFloat(@unicode:characters_to_binary(chs))
      }
    }
}

impl ToFloat for String {
  to_float(s) =
    let result = match @string:next_grapheme(s) {
      ['.' | _] => @string:to_float(['0', assume s])
      _ => @string:to_float(s)
    }
    match result {
      (f, "") => f
      // If we prepend a 0 above, on a successful parse, we'll get back an empty
      // list instead of an empty string.
      (f, []) => f
      _ => match @string:to_integer(s) {
        (i, "") => to_float(i : Int)
        _ => raise CantParseFloat(s)
      }
    }
}

interface ToChar {
  to_char : T -> Char
}

impl ToChar for Int {
  to_char(i) = assume i
}

interface ToAtom {
  to_atom : T -> Atom
}

impl ToAtom for Char {
  to_atom(c) = to_atom([c])
}

impl ToAtom for [Char] {
  to_atom = @erlang:list_to_atom/1
}

impl ToAtom for String {
  to_atom(s) = @erlang:binary_to_atom(s, @utf8)
}

interface ToList {
  to_list : T<A> -> [A]
}

impl ToList for Set {
  to_list(s) = @maps:keys(@maps:remove(@"_@type", s))
}

impl ToList for Map {
  to_list(m) = @maps:to_list(m)
}

interface ToSet {
  to_set : T<A> -> Set<A>
}

impl ToSet for List {
  to_set(l) =
    let pairs = map(l, |a| (a, true))
    @maps:from_list([assume (@"_@type", @Set) | pairs])
}

impl ToSet for Map {
  to_set(m) = to_list(m) |> to_set
}

interface ToMap {
  to_map : T<K, V> -> Map<K, V>
}

impl ToMap for List {
  to_map(l) = @maps:from_list(l)
}

impl ToMap for Set {
  to_map(s) = to_list(s) |> to_map
}

to_str : A -> String
export to_str = @par_native:to_str/1

to_pretty : A -> String
export to_pretty(a) = @par_native:to_pretty(a, 80, 0)

//-- Misc
print : A -> ()
export print(a) =
  @io:format("~s~n", [to_pretty(a)])
  ()

debug : (A, String) -> ()
export debug(a, prefix) =
  @io:format("~s: ~s~n", [prefix, to_pretty(a)])
  ()
