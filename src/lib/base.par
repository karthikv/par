module Base

//-- Types
enum Option<T> {
  Some(T)
  None
}


//-- Interfaces/Implementations
interface Sized {
  length : T -> Int
  empty? : T -> Bool
}

impl Sized for String {
  length = @string:length/1
  empty?(s) = s == ""
}

impl Sized for [A] {
  length = @erlang:length/1
  empty?(l) = l == []
}

impl Sized for Set<A> {
  // subtract 1 to get rid of tag
  length(s) = @erlang:map_size(s) - 1
  empty?(s) = length(s) == 0
}

impl Sized for Map<A, B> {
  length = @erlang:map_size/1
  empty?(m) = m == {}
}

interface Mappable {
  map : (A -> B) -> T<A> -> T<B>
}

impl Mappable for Option {
  map(f, o) = match o {
    Some(a) => Some(f(a))
    None => None
  }
}

impl Mappable for List {
  map = @lists:map/2
}

impl Mappable for Set {
  map(f, s) = map(f, to_list(s)) |> to_set
}

impl Mappable for Map {
  map(f, m) = @maps:fold(|k, v, new_m|
    let (new_k, new_v) = f((k, v))
    @maps:put(new_k, new_v, new_m)
  , {}, m)
}

interface Collection extends Mappable {
  fold : (A -> F -> F) -> F -> T<A> -> F
  filter : (A -> Bool) -> T<A> -> T<A>
  find : (A -> Bool) -> T<A> -> Option<A>

  filter_map : (A -> Option<B>) -> T<A> -> T<B>
  map_fold : (A -> F -> (B, F)) -> F -> T<A> -> (T<B>, F)

  put : A -> T<A> -> T<A>
  delete : A -> T<A> -> T<A>

  contains? : A -> T<A> -> Bool
  all? : (A -> Bool) -> T<A> -> Bool
  any? : (A -> Bool) -> T<A> -> Bool
}

impl Collection for List {
  fold = @lists:foldl/3
  filter = @lists:filter/2
  find(f, l) = match l {
    [] => None
    [h | t] => if f(h) then Some(h) else find(f, t)
  }

  filter_map(f, l) = @lists:filtermap(|a|
    if let Some(b) = f(a) then
      assume (true, b)
    else
      false
  , l)
  map_fold = @lists:mapfoldl/3

  put(h, t) = [h | t]
  delete(a, l) = match l {
    [] => []
    [&a | t] => delete(a, t)
    [h | t] => [h | delete(a, t)]
  }

  contains?(a, l) = match l {
    [] => false
    [&a | _] => true
    [_ | t] => contains?(a, t)
  }
  all? = @lists:all/2
  any? = @lists:any/2
}

impl Collection for Set {
  fold(f, init, s) = to_list(s) |> fold(f, init)
  filter(f, s) = @maps:filter(|k, _| assume k == @"_@type" || f(k), s)
  find(f, s) = to_list(s) |> find(f)

  filter_map(f, s) = to_list(s) |> filter_map(|a| f(a)) |> to_set
  map_fold(f, init, s) =
    let (l, memo) = to_list(s) |> map_fold(|a, memo| f(a, memo), init)
    (to_set(l), memo)

  put(a, s) = @maps:put(a, true, s)
  delete = @maps:remove/2

  contains? = @maps:is_key/2
  all?(f, s) = to_list(s) |> all?(f)
  any?(f, s) = to_list(s) |> any?(f)
}

impl Collection for Map {
  fold(f, init, m) = @maps:fold(|k, v, memo| f((k, v), memo), init, m)
  filter(f, m) = @maps:filter(|k, v| f((k, v)), m)
  find(f, m) = to_list(m) |> find(f)

  filter_map(f, m) = to_list(m) |> filter_map(f) |> to_map
  map_fold(f, init, m) =
    let (pairs, memo) = to_list(m) |> map_fold(f, init)
    (to_map(pairs), memo)

  put((k, v), m) = @maps:put(k, v, m)
  delete((k, v), m) = if contains?((k, v), m) then @maps:remove(k, m) else m

  contains?((k, v), m) = match @maps:find(k, m) {
    (@ok, &v) => true
    _ => false
  }
  all?(f, m) = to_list(m) |> all?(f)
  any?(f, m) = to_list(m) |> any?(f)
}


//-- Exceptions
// used in List and String modules
exception BadIndex(Int)


//-- Collections
first : (A, B) -> A
export first((a, _)) = a

second : (A, B) -> B
export second((_, b)) = b

head : [A] -> A
export head = @erlang:hd/1

tail : [A] -> [A]
export tail = @erlang:tl/1


//-- Math
abs : A ~ Num -> A ~ Num
export abs = @erlang:abs/1

ceil : Float -> Int
export ceil = @erlang:ceil/1

floor : Float -> Int
export floor = @erlang:floor/1

max : A ~ Ord -> A ~ Ord -> A ~ Ord
export max(a, b) = if a > b then a else b

min : A ~ Ord -> A ~ Ord -> A ~ Ord
export min(a, b) = if a < b then a else b

round : Float -> Int
export round = @erlang:round/1

trunc : Float -> Int
export trunc = @erlang:trunc/1


//-- Conversions
interface ToInt {
  to_int : T -> Int
}

// TODO: exceptions for conversions?
impl ToInt for Float {
  to_int = trunc
}

impl ToInt for Char {
  to_int(c) = assume c
}

impl ToInt for [Char] {
  to_int = @erlang:list_to_integer/1
}

impl ToInt for String {
  to_int = @erlang:binary_to_integer/1
}

interface ToFloat {
  to_float : T -> Float
}

impl ToFloat for Int {
  to_float = @erlang:float/1
}

// TODO support integer parsing for both of these to_float versions
impl ToFloat for [Char] {
  to_float = @erlang:list_to_float/1
}

impl ToFloat for String {
  to_float = @erlang:binary_to_float/1
}

interface ToChar {
  to_char : T -> Char
}

impl ToChar for Int {
  to_char(i) = assume i
}

interface ToAtom {
  to_atom : T -> Atom
}

impl ToAtom for Char {
  to_atom(c) = to_atom([c])
}

impl ToAtom for [Char] {
  to_atom = @erlang:list_to_atom/1
}

impl ToAtom for String {
  to_atom(s) = @erlang:binary_to_atom(s, @utf8)
}

interface ToList {
  to_list : T<A> -> [A]
}

impl ToList for Set {
  to_list(s) = @maps:keys(@maps:remove(@"_@type", s))
}

impl ToList for Map {
  to_list(m) = @maps:to_list(m)
}

interface ToSet {
  to_set : T<A> -> Set<A>
}

impl ToSet for List {
  to_set(l) =
    let pairs = map(|a| (a, true), l)
    @maps:from_list([assume (@"_@type", @Set) | pairs])
}

impl ToSet for Map {
  to_set(m) = to_list(m) |> to_set
}

interface ToMap {
  to_map : T<K, V> -> Map<K, V>
}

impl ToMap for List {
  to_map(l) = @maps:from_list(l)
}

impl ToMap for Set {
  to_map(s) = to_list(s) |> to_map
}

to_str : A -> String
export to_str = @par_native:to_str/1

// TODO: Concatable, Separable interfaces


//-- Misc
print : A -> ()
export print(a) =
  @io:format("~s~n", [to_str(a)])
  ()

flip : (A -> B -> C) -> B -> A -> C
export flip(f, b, a) = f(a, b)
