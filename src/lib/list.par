module List

import Base (*)
import Map

impl Sized for [A] {
  length = @erlang:length/1
  empty?(l) = l == []
}

impl Mappable for List {
  map(l, f) = @lists:map(f, l)
}

impl Collection for List {
  fold(l, init, f) = @lists:foldl(f, init, l)
  filter(l, f) = @lists:filter(f, l)
  find(l, f) = match l {
    [] => None
    [h | t] => if f(h) then Some(h) else find(t, f)
  }

  filter_map(l, f) = @lists:filtermap(|a|
    if let Some(b) = f(a) then
      assume (true, b)
    else
      false
  , l)
  map_fold(l, init, f) = @lists:mapfoldl(f, init, l)

  put(l, h) = [h | l]
  delete(l, a) = match l {
    [] => []
    [&a | t] => delete(t, a)
    [h | t] => [h | delete(t, a)]
  }

  contains?(l, a) = match l {
    [] => false
    [&a | _] => true
    [_ | t] => contains?(t, a)
  }
  all?(l, f) = @lists:all(f, l)
  any?(l, f) = @lists:any(f, l)
}

impl ToSet for List {
  to_set(l) =
    let pairs = map(l, |a| (a, true))
    @maps:from_list([assume (@"_@type", @Set) | pairs])
}

// @replace T<K, V> => [(K, V)]
impl ToMap for List {
  to_map(l) = @maps:from_list(l)
}

exception BadListIndex(Int)
exception MismatchedLengths(Int, Int)

max_in : [A ~ Ord] -> Option<A ~ Ord>
export max_in(l) = match l {
  [] => None
  _ => Some(@lists:max(l))
}

min_in : [A ~ Ord] -> Option<A ~ Ord>
export min_in(l) = match l {
  [] => None
  _ => Some(@lists:min(l))
}

max_by : ([A], A -> B ~ Ord) -> Option<A>
export max_by(l, f) = match l {
  [] => None
  [h | t] =>
    let (max, _) = fold(t, (h, f(h)), |x, (max, max_key)|
      let x_key = f(x)
      if x_key > max_key then (x, x_key) else (max, max_key)
    )
    Some(max)
}

min_by : ([A], A -> B ~ Ord) -> Option<A>
export min_by(l, f) = match l {
  [] => None
  [h | t] =>
    let (min, _) = fold(t, (h, f(h)), |x, (min, min_key)|
      let x_key = f(x)
      if x_key < min_key then (x, x_key) else (min, min_key)
    )
    Some(min)
}

take_while : ([A], A -> Bool) -> [A]
export take_while(l, f) = @lists:takewhile(f, l)

drop_while : ([A], A -> Bool) -> [A]
export drop_while(l, f) = @lists:dropwhile(f, l)

split_while : ([A], A -> Bool) -> ([A], [A])
export split_while(l, f) = @lists:splitwith(f, l)

repeat : (A, Int) -> [A]
export repeat(a, n) = @lists:duplicate(n, a)

flat_map : ([A], A -> [B]) -> [B]
export flat_map(l, f) = @lists:flatmap(f, l)

foldr : ([A], F, (A, F) -> F) -> F
export foldr(l, init, f) = @lists:foldr(f, init, l)

map_foldr : ([A], F, (A, F) -> (B, F)) -> ([B], F)
export map_foldr(l, init, f) = @lists:mapfoldr(f, init, l)

partition : ([A], A -> Bool) -> ([A], [A])
export partition(l, f) = @lists:partition(f, l)

reverse : [A] -> [A]
export reverse = @lists:reverse/1

seq : (Int, Int) -> [Int]
export seq(start, end) =
  if start <= end then
    [start | seq(start + 1, end)]
  else
    []

sum : [A ~ Num] -> A ~ Num
export sum = @lists:sum/1

sort : [A ~ Ord] -> [A ~ Ord]
export sort = @lists:sort/1

sort_by : ([A], A -> B ~ Ord) -> [A]
export sort_by(l, f) = @lists:sort(|a, b| f(a) < f(b), l)

sort_cmp : ([A], (A, A) -> Bool) -> [A]
export sort_cmp(l, f) = @lists:sort(f, l)

nth : ([A], Int) -> A
export nth(l, i) =
  let wrapped_i = if i < 0 then length(l) + i else i
  if wrapped_i < 0 then raise BadListIndex(i) else nth_r(l, 0, wrapped_i)

nth_r : ([A], Int, Int) -> A
nth_r(l, i, n) = match l {
  [h | t] => if i == n then h else nth_r(t, i + 1, n)
  [] => raise BadListIndex(i)
}

split_at : ([A], Int) -> ([A], [A])
export split_at(l, i) =
  let wrapped_i = if i < 0 then length(l) + i else i
  if wrapped_i < 0 then
    raise BadListIndex(i)
  else
    split_at_r(l, 0, wrapped_i, [])

split_at_r : ([A], Int, Int, [A]) -> ([A], [A])
split_at_r(l, i, n, before) =
  if l == [] then
    raise BadListIndex(i)
  else if i == n then
    (reverse(before), l)
  else
    let [h | t] = l
    split_at_r(t, i + 1, n, [h | before])

slice : ([A], Int, Int) -> [A]
export slice(l, i, num) =
  if num <= 0 then
    []
  else
    let wrapped_i = if i < 0 then length(l) + i else i
    if wrapped_i < 0 then
      raise BadListIndex(i)
    else
      slice_r(l, 0, wrapped_i, num)

range : ([A], Int, Int) -> [A]
export range(l, start, end) =
  let len = if start < 0 || end < 0 then length(l) else 0
  let wrapped_start = if start < 0 then len + start else start
  let wrapped_end = if end < 0 then len + end else end

  if wrapped_start > wrapped_end then
    []
  else if wrapped_start < 0 then
    raise BadListIndex(start)
  else if wrapped_end < 0 then
    raise BadListIndex(end)
  else
    slice_r(l, 0, wrapped_start, wrapped_end - wrapped_start + 1)

slice_r : ([A], Int, Int, Int) -> [A]
slice_r(l, i, start, num) =
  if num <= 0 then
    []
  else
    match l {
      [h | t] =>
        if i >= start then
          [h | slice_r(t, i + 1, start, num - 1)]
        else
          slice_r(t, i + 1, start, num)
      [] => raise BadListIndex(i)
    }

join : ([String], String) -> String
export join(l, start) = @unicode:characters_to_binary(intersperse(l, start))

intersperse : ([A], A) -> [A]
intersperse(l, a) = match l {
  [] => []
  [h] => [h]
  [h | t] => [h, a | intersperse(t, a)]
}

zip : ([A], [B]) -> [(A, B)]
export zip(l1, l2) = zip_r(l1, l2, 0)

zip_r : ([A], [B], Int) -> [(A, B)]
zip_r(l1, l2, i) = match (l1, l2) {
  ([h1 | t1], [h2 | t2]) => [(h1, h2) | zip_r(t1, t2, i + 1)]
  ([], []) => []
  _ => raise MismatchedLengths(i + length(l1), i + length(l2))
}

unzip : [(A, B)] -> ([A], [B])
export unzip = @lists:unzip/1

group_by : ([A], A -> B) -> Map<B, [A]>
export group_by(l, f) =
  foldr(l, {}, |a, m| Map.upsert(m, f(a), [a], |group| [a | group]))

unique : [A] -> [A]
export unique(l) =
  let (unique_l_rev, _) = fold(l, ([], #[]), |a, (new_l, s)|
    if contains?(s, a) then
      (new_l, s)
    else
      ([a | new_l], put(s, a))
  )

  reverse(unique_l_rev)

unique_by : ([A], A -> B) -> [A]
export unique_by(l, f) =
  let (unique_l_rev, _) = fold(l, ([], #[]), |a, (new_l, s)|
    let key = f(a)
    if contains?(s, key) then
      (new_l, s)
    else
      ([a | new_l], put(s, key))
  )

  reverse(unique_l_rev)

with_index : [A] -> [(A, Int)]
export with_index(l) = with_index_r(l, 0)

with_index_r : ([A], Int) -> [(A, Int)]
with_index_r(l, i) = match l {
  [h | t] => [(h, i) | with_index_r(t, i + 1)]
  [] => []
}

each : ([A], A -> B) -> ()
export each(l, f) =
  @lists:foreach(f, l)
  ()
