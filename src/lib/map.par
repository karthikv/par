module Map

import Base (*)

impl Sized for Map<K, V> {
  length = @erlang:map_size/1
  empty?(m) = m == {}
}

// @replace T<A> => Map<K, V>
// | A => (K, V)
// | T<B> => Map<L, M>
// | B => (L, M)
impl Mappable for Map {
  map(m, f) = @maps:fold(|k, v, new_m|
    let (new_k, new_v) = f((k, v))
    @maps:put(new_k, new_v, new_m)
  , {}, m)
}

// @replace T<A> => Map<K, V>
// | A => (K, V)
// | T<B> => Map<L, M>
// | B => (L, M)
impl Collection for Map {
  fold(m, init, f) = @maps:fold(|k, v, memo| f((k, v), memo), init, m)
  filter(m, f) = @maps:filter(|k, v| f((k, v)), m)
  find(m, f) = to_list(m) |> find(f)

  filter_map(m, f) = to_list(m) |> filter_map(f) |> to_map
  map_fold(m, init, f) =
    let (pairs, memo) = to_list(m) |> map_fold(init, f)
    (to_map(pairs), memo)

  put(m, (k, v)) = @maps:put(k, v, m)
  delete(m, (k, v)) = if contains?(m, (k, v)) then @maps:remove(k, m) else m

  contains?(m, (k, v)) = match @maps:find(k, m) {
    (@ok, &v) => true
    _ => false
  }
  all?(m, f) = to_list(m) |> all?(f)
  any?(m, f) = to_list(m) |> any?(f)
}

// @replace T<A> => Map<K, V>
// | A => (K, V)
impl ToList for Map {
  to_list(m) = @maps:to_list(m)
}

// @replace T<A> => Map<K, V>
// | A => (K, V)
impl ToSet for Map {
  to_set(m) = to_list(m) |> to_set
}

get_or : (Map<K, V>, K, V) -> V
export get_or(m, k, default) = match @maps:find(k, m) {
  (@ok, v) => v
  @error => default
}

keys : Map<K, V> -> [K]
export keys = @maps:keys/1

values : Map<K, V> -> [V]
export values = @maps:values/1

update : (Map<K, V>, K, V -> V) -> Map<K, V>
export update(m, k, f) = match @maps:find(k, m) {
  (@ok, v) => @maps:put(k, f(v), m)
  @error => raise BadKey
}

upsert : (Map<K, V>, K, V, V -> V) -> Map<K, V>
export upsert(m, k, default, f) = match @maps:find(k, m) {
  (@ok, v) => @maps:put(k, f(v), m)
  @error => @maps:put(k, default, m)
}

merge : (Map<K, V>, Map<K, V>) -> Map<K, V>
export merge = @maps:merge/2

with : (Map<K, V>, [K]) -> Map<K, V>
export with(m, keys) = @maps:with(keys, m)

without : (Map<K, V>, [K]) -> Map<K, V>
export without(m, keys) = @maps:without(keys, m)
