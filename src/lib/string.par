module String

import Base (*)
import List

struct Regexp {
  re : Native
  str : String
}

enum RegexpOpt {
  Caseless @caseless
  Multiline @multiline
  DotAll @dotall
  Extended @extended
  UnicodeCharProps @ucp
}

exception BadRegexp({ reason : String, index : Int })

chars : String -> [Char]
export chars(s) = match @string:next_codepoint(s) {
  [h | t] => [h | chars(assume t)]
  [] => []
}

from_chars : [Char] -> String
export from_chars = @unicode:characters_to_binary/1

capitalize : String -> String
export capitalize(s) =
  if empty?(s) then
    s
  else
    let [g | t] = @string:next_grapheme(s)
    @erlang:iolist_to_binary([@string:to_upper([g]) | t])

to_lower : String -> String
export to_lower = @string:lowercase/1

to_upper : String -> String
export to_upper = @string:uppercase/1

lstrip : String -> String
export lstrip(s) = @string:trim(s, @leading)

rstrip : String -> String
export rstrip(s) = @string:trim(s, @trailing)

strip : String -> String
export strip(s) = @string:trim(s, @both)

slice : (String, Int, Int) -> String
export slice(s, i, num) =
  if num <= 0 then
    ""
  else
    let wrapped_i = if i < 0 then length(s) + i else i
    if wrapped_i < 0 then
      raise BadIndex(i)
    else
      slice_r(s, 0, wrapped_i, num) |> @erlang:iolist_to_binary/1

range : (String, Int, Int) -> String
export range(s, start, end) =
  let len = if start < 0 || end < 0 then length(s) else 0
  let wrapped_start = if start < 0 then len + start else start
  let wrapped_end = if end < 0 then len + end else end

  if wrapped_start > wrapped_end then
    ""
  else if wrapped_start < 0 then
    raise BadIndex(start)
  else if wrapped_end < 0 then
    raise BadIndex(end)
  else
    slice_r(s, 0, wrapped_start, wrapped_end - wrapped_start + 1)
    |> @erlang:iolist_to_binary/1

slice_r : (String, Int, Int, Int) -> [Char]
slice_r(s, i, start, num) =
  if num <= 0 then
    []
  else
    match @string:next_grapheme(s) {
      [h | t] =>
        if i >= start then
          [h | slice_r(assume t, i + 1, start, num - 1)]
        else
          slice_r(assume t, i + 1, start, num)
      [] => raise BadIndex(i)
    }

lines : String -> [String]
export lines(s) = @binary:split(s, newline_pattern, [@global, @trim])

newline_pattern : Native
newline_pattern = @binary:compile_pattern(["\n", "\r\n"])

reverse : String -> String
export reverse(s) = @string:reverse(s) |> @erlang:iolist_to_binary/1

starts_with? : (String, String) -> Bool
export starts_with?(s, prefix) = @string:prefix(s, prefix) != @nomatch

ends_with? : (String, String) -> Bool
export ends_with?(s, suffix) = @string:find(s, suffix, @trailing) == suffix

substr? : (String, String) -> Bool
export substr?(s, sub) = @string:find(s, sub) != @nomatch

re : (String, [RegexpOpt]) -> Regexp
export re(s, opts) =
  let opts = [assume @unicode, assume (@newline, @anycrlf) | opts]
  match @re:compile(s, opts) {
    (@error, (reason, index)) =>
      raise BadRegexp({ reason = from_chars(reason), index = index })
    (@ok, re) => Regexp { re = re, str = s }
  }

matches? : (String, Regexp) -> Bool
export matches?(s, r) = @re:run(s, r.re) != @nomatch

search : (String, Regexp) -> [String]
export search(s, r) = match @re:run(s, r.re, [(@capture, @all, @binary)]) {
  @nomatch => []
  (@match, results) => results
}

search_all : (String, Regexp) -> [[String]]
export search_all(s, r) =
  match @re:run(s, r.re, [@global, assume (@capture, @all, @binary)]) {
    @nomatch => []
    (@match, results) => results
  }

span : (String, String) -> Option<(String, String)>
export span(s, sub) =
  if sub == "" then
    None
  else
    match splitn(s, sub, 2) {
      [l, r] => Some((l, r))
      [_] => None
    }

rspan : (String, String) -> Option<(String, String)>
export rspan(s, sub) =
  if sub == "" then
    None
  else
    match @string:split(s, sub, @trailing) {
      [l, r] => Some((l, r))
      [_] => None
    }

search_span : (String, Regexp) -> Option<(String, [String], String)>
export search_span(s, r) =
  if r.str == "" then
    None
  else
    match splitn(s, r, 2) {
      [_] => None
      [l | t] =>
        let (matches, [r]) = List.split_at(t, -1)
        Some((l, matches, r))
    }

interface Pattern {
  splitn : (String, T, Int) -> [String]
  replace : (String, T, String) -> String
  replace_one : (String, T, String) -> String
}

impl Pattern for String {
  splitn(s, sub, n) =
    if sub == "" then
      if n <= 0 then
        @string:to_graphemes(s) : [Char] |> map(|ch| from_chars([ch]))
      else
        splitn_graphemes(s, n)
    else if n <= 0 then
      @string:split(s, sub, @all)
    else
      splitn_r(s, sub, n)
  replace(s, sub, rep) =
    if sub == "" then
      let parts = split(s, "") |> map(|s| [s, assume rep])
      @erlang:iolist_to_binary([assume rep, parts])
    else
      @string:replace(s, sub, rep, @all) |> @erlang:iolist_to_binary/1
  replace_one(s, sub, rep) =
    if sub == "" then
      rep ++ s
    else
      @string:replace(s, sub, rep) |> @erlang:iolist_to_binary/1
}

splitn_graphemes : (String, Int) -> [String]
splitn_graphemes(s, n) =
  if n <= 1 then
    [s]
  else
    match @string:next_grapheme(s) {
      [h | t] => [from_chars([h]) | splitn_graphemes(assume t, n - 1)]
      [] => [s]
    }

splitn_r : (String, String, Int) -> [String]
splitn_r(s, sub, n) =
  if n <= 1 then
    [s]
  else
    match @string:split(s, sub, @leading) {
      [_] => [s]
      [l, r] => [l | splitn_r(r, sub, n - 1)]
    }

impl Pattern for Regexp {
  splitn(s, r, n) =
    if r.str == "" then
      splitn(s, "", n)
    else if n <= 0 then
      @re:split(s, r.re, [(@return, @binary)])
    else
      @re:split(s, r.re, [(@parts, n), assume (@return, @binary)])
  replace(s, r, rep) =
    @re:replace(s, r.re, rep, [@global, assume (@return, @binary)])
  replace_one(s, r, rep) = @re:replace(s, r.re, rep, [(@return, @binary)])
}

split : (String, T ~ Pattern) -> [String]
export split(s, r) = splitn(s, r, -1)
